<application>
  <component name="PersistentConfiglabuladong">
    <option name="initConfig">
      <Config>
        <option name="codeType" value="Python3" />
        <option name="customTemplate" value="# region init&#10;&#10;from typing import *&#10;import math&#10;from collections import defaultdict&#10;&#10;&#10;class ListNode:&#10;    pass&#10;&#10;&#10;# endregion init&#10;&#10;${question.code}&#10;&#10;# region auto_test&#10;&#10;&#10;question_content = '''&#10;${question.content}&#10;'''&#10;&#10;question_code = '''&#10;$!velocityTool.snakeCaseName(${question.code})&#10;'''&#10;&#10;&#10;# Definition for singly-linked list.&#10;class ListNode:&#10;    def __init__(self, val=0, next=None):&#10;        self.val = val&#10;        self.next = next&#10;&#10;&#10;def is_input_linked_list(str_question: str) -&gt; bool:&#10;    import operator&#10;    return operator.contains(str_question, &quot;#_definition_for_singly_linked_list.&quot;)&#10;&#10;&#10;def is_return_linked_list(str_question: str) -&gt; bool:&#10;    import operator&#10;    answer = \&#10;        operator.contains(str_question, &quot;_-&gt;_list_node&quot;) or \&#10;        operator.contains(str_question, &quot;_-&gt;_optional[_list_node]&quot;)&#10;    return answer&#10;&#10;&#10;def convert_to_linkedlist(numbers: list) -&gt; ListNode:&#10;    fixed = ListNode()&#10;    dynamic = fixed&#10;    for number in numbers:&#10;        temp = ListNode(number)&#10;        dynamic.next = temp&#10;        dynamic = dynamic.next&#10;    return fixed.next&#10;&#10;&#10;def convert_to_list(head: ListNode) -&gt; list:&#10;    result = []&#10;    while head:&#10;        result.append(head.val)&#10;        head = head.next&#10;    return result&#10;&#10;&#10;def load_args(args_name_and_value: list, linked_list: bool) -&gt; dict:&#10;    import json&#10;    loaded_args = {}&#10;    for arg_name_and_value in args_name_and_value:&#10;        arg_name, arg_value = arg_name_and_value.replace(' ', '').split(&quot;=&quot;)&#10;        arg_value = json.loads(arg_value)&#10;        if linked_list and type(arg_value) == list:&#10;            arg_value = convert_to_linkedlist(arg_value)&#10;        loaded_args[arg_name] = arg_value&#10;    return loaded_args&#10;&#10;&#10;def get_test_cases(str_examples: str, linked_list: bool):&#10;    import re&#10;    import json&#10;    examples = re.split('Example.+?:', str_examples)[1:]&#10;    all_input, all_output = [], []&#10;    for example in examples:&#10;        input_flag = 0&#10;        output_flag = 0&#10;        lines = example.split('\n')&#10;        for line in lines:&#10;            line = line.strip()&#10;            if line.startswith('Input: '):&#10;                args_name_and_value = line.replace('Input: ', '').split(', ')&#10;                input_flag += 1&#10;                loaded_args = load_args(args_name_and_value, linked_list)&#10;                all_input.append(loaded_args)&#10;                continue&#10;            if line.startswith('Output: '):&#10;                output = json.loads(line.replace('Output: ', ''))&#10;                output_flag += 1&#10;                all_output.append(output)&#10;&#10;        if input_flag != 1 or output_flag != 1:&#10;            raise RuntimeError('Example extraction error. Please checke &quot;question_content&quot;')&#10;    return zip(all_input, all_output)&#10;&#10;&#10;def auto_test(input_and_output: zip, linked_list: bool):&#10;    function = getattr(Solution(), dir(Solution())[-1])&#10;    wrong_answer_cunter = 0&#10;    for input_, output in input_and_output:&#10;        your_answer = function(**input_)&#10;        if linked_list or type(your_answer) == ListNode:&#10;            your_answer = convert_to_list(your_answer)&#10;        for arg_name, arg_value in input_.items():&#10;            if type(arg_value) == ListNode:&#10;                input_[arg_name] = convert_to_list(arg_value)&#10;        message = f&quot;Input: {input_}, Output: {output}\nYour answer: \033[31m{your_answer}\033[0m&quot;&#10;        try:&#10;            assert your_answer == output, message&#10;        except AssertionError as e:&#10;            wrong_answer_cunter += 1&#10;            print(&quot;\n&quot;, e)&#10;&#10;    if wrong_answer_cunter &gt; 0:&#10;        return '\033[31mWrong Answer\033[0m'&#10;    else:&#10;        return '\033[32mAccepted\033[0m'&#10;&#10;&#10;# endregion auto_test&#10;&#10;if __name__ == '__main__':&#10;    input_linked_list = is_input_linked_list(question_code)&#10;    return_linked_list = is_return_linked_list(question_code)&#10;&#10;    test_cases = get_test_cases(question_content, input_linked_list)&#10;&#10;    print('\n', auto_test(test_cases, return_linked_list))&#10;" />
        <option name="filePath" value="E:\my_leetcode" />
        <option name="id" value="68211747128587391" />
        <option name="pluginVersion" value="3.1.0" />
        <option name="siteCookie" value="" />
        <option name="url" value="leetcode.com" />
        <option name="version" value="3" />
      </Config>
    </option>
  </component>
</application>